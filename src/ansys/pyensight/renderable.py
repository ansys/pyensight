"""Renderable module

Interface to create objects in the EnSight session that can be displayed
via HTML over the websocketserver interface.
"""
import json
import os
import shutil
from typing import Any, List, Optional
import uuid
import webbrowser

import requests


class Renderable:
    """Generate HTML pages for renderable entities

    This class provides the underlying HTML remote webpage generation for
    the Session 'show()' method.  The approach is to generate the renderable
    in the EnSight session and make the artifacts available via the websocketserver.
    The artifacts are then wrapped with simple HTML pages (also served up by
    websocket server) which can be used to populate iframes, etc.

    Args:
        session:
            The pyansys session to generate the renderables for
    """

    def __init__(
        self,
        session: "pyansys.Session",
        cell_handle: Optional[Any] = None,
        width: Optional[int] = None,
        height: Optional[int] = None,
        temporal: bool = False,
        aa: int = 1,
        fps: float = 30.0,
    ) -> None:
        self._session = session
        self._filename_index: int = 0
        self._guid: str = str(uuid.uuid1()).replace("-", "")
        self._download_names: list[str] = []
        # The Jupyter notebook cell handle (if any)
        self._cell_handle = cell_handle
        # the URL to the base HTML file for this entity
        self._url: Optional[str] = None
        # the pathname of the HTML file in the remote EnSight session
        self._url_remote_pathname: Optional[str] = None
        # the name passed to the pyensight session show() string
        self._rendertype: str = ""
        # Common attributes used by various subclasses
        self._width: Optional[int] = width
        self._height: Optional[int] = height
        self._temporal: bool = temporal
        self._aa: int = aa
        self._fps: float = fps

    def __repr__(self) -> str:
        name = self.__class__.__name__
        return f"{name}( url='{self._url}' )"

    def _repr_pretty_(self, p: "pretty", cycle: bool) -> None:
        """Support the pretty module for better IPython support"""
        name = self.__class__.__name__
        p.text(f"{name}( url='{self._url}' )")

    def _generate_filename(self, suffix: str) -> (str, str):
        """Create new session specific files and urls

        Every time this method is called, a new filename (on the EnSight host)
        and the associated URL for that file are generated.  The caller
        provides the suffix for the names.

        Args:
             suffix:
                The suffix to be appended to the names.  For example: ".png"
        Returns:
            the filename to use on the host system and the URL that accesses the
            file via REST calls to websocketserver
        """
        filename = f"{self._session.secret_key}_{self._guid}_{self._filename_index}{suffix}"
        # Note: cannot use os.path.join here as the OS of the EnSight session might not match
        # the client OS.
        pathname = f"{self._session.launcher.session_directory}/{filename}"
        self._filename_index += 1
        return pathname, filename

    def _generate_url(self) -> None:
        """Build the remote HTML filename and associated URL

        On the remote system the pathname to the HTML file will be:
            {session_directory}/{session}_{guid}_{index}_{type}.html
        The URL to the file (through the session HTTP server):
            http://{system}:{websocketserverhtmlport}/{session}_{guid}_{index}_{type}.html

        After this call, the _url and _url_remote_pathane will reflect those names.
        """
        suffix = f"_{self._rendertype}.html"
        filename_index = self._filename_index
        remote_pathname, _ = self._generate_filename(suffix)
        simple_filename = f"{self._session.secret_key}_{self._guid}_{filename_index}{suffix}"
        url = f"http://{self._session.hostname}:{self._session.html_port}/{simple_filename}"
        self._url = url
        self._url_remote_pathname = remote_pathname

    def _save_remote_html_page(self, html: str) -> None:
        """Create an HTML webpage on the remote host

        Given a snippet of HTML, create a new file on the remote server with the
        name generated by _generate_url().
        The most common use is to generate an "iframe" wrapper around some html.

        Args:
            html:
                The HTML snippet to be wrapped remotely
        """
        # save "html" into a file on the remote server with filename .html
        cmd = f'open(r"""{self._url_remote_pathname}""", "w").write("""{html}""")'
        self._session.grpc.command(cmd, do_eval=False)

    def browser(self) -> None:
        """Open a webbrowser page to display the renderable content"""
        if self._url:
            webbrowser.open(self._url)

    @property
    def url(self) -> str:
        """The URL to the renderable content"""
        return self._url

    def _default_size(self, width: int, height: int) -> (int, int):
        """Propose and return a size for a rectangle

        The renderable may have been constructed with user-supplied width and height
        information.  If so, that information is returned.  If not, the width and
        height values passed to this method are returned.

        Args:
            width:
                The width value to be returned if the renderable does not have a width
            height:
                The height value to be returned if the renderable does not have a height

        Returns:
            A tuple (width, height) of the size values to be used.
        """
        out_w = self._width
        if out_w is None:
            out_w = width
        out_h = self._height
        if out_h is None:
            out_h = height
        return out_w, out_h

    def update(self) -> None:
        """Update the visualization and display it

        When this method is called, the graphics content will be updated to the
        current EnSight instance state (e.g. an image might be re-captured).  The
        URL of the content stays the same, but the content that URL displays is
        updated.

        If the renderable was created in the context of a Jupyter notebook cell,
        the original cell display is updated.
        """
        if self._cell_handle:
            from IPython.display import IFrame

            width, height = self._default_size(800, 600)
            self._cell_handle.update(IFrame(src=self._url, width=width, height=height))

    def delete(self) -> None:
        """Delete all the server resources for this renderable

        A renderable occupies resources in the EnSight session instance.  This
        method will release those resources.  Once it is called, the renderable can
        no longer be displayed.

        Note: this method has not yet been implemented.
        """
        pass

    def download(self, dirname: str) -> List[str]:
        """Download the content files for this renderable

        A renderable saves files (image, mpeg, geometry, etc) in the EnSight instance.
        Normally, these files are accessed via the web page specified in the url property.
        This method allows for those files to be downloaded to a local directory so they
        can be used for other purposes. Note: any previously existing files with the
        same name will be overwritten.

        Args:
            dirname:
                The name of the existing directory to save the files into.

        Returns:
            A list of the filenames that were downloaded.

        Examples:
            Download the png file generated by the image renderable::

                img = session.show('image", width=640, height=480, aa=4)
                names = img.download("/tmp")
                png_pathname = os.path.join("/tmp", names[0])

        """
        for filename in self._download_names:
            url = f"http://{self._session.hostname}:{self._session.html_port}/{filename}"
            outpath = os.path.join(dirname, filename)
            with requests.get(url, stream=True) as r:
                with open(outpath, "wb") as f:
                    shutil.copyfileobj(r.raw, f)
        return self._download_names


class RenderableImage(Renderable):
    """Image renderable

    Render an image on the EnSight host system and make it available via
    a webpage.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "image"
        self._generate_url()
        # the HTML serves up a PNG file
        pathname, filename = self._generate_filename(".png")
        self._png_pathname = pathname
        self._png_filename = filename
        # the download is the png file
        self._download_names.append(self._png_filename)
        self.update()

    def update(self):
        """Update the image and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        # save the image file on the remote host
        w, h = self._default_size(1920, 1080)
        cmd = f'ensight.render({w},{h},num_samples={self._aa}).save(r"""{self._png_pathname}""")'
        self._session.cmd(cmd)
        # generate HTML page with file references local to the websocketserver root
        html = f'<img src="/{self._png_filename}">\n'
        # refresh the remote HTML
        self._save_remote_html_page(html)
        super().update()


class RenderableDeepPixel(Renderable):
    """Deep Image renderable

    Render a deep pixel image on the EnSight host system and make it available via
    a webpage.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "deep_pixel"
        self._generate_url()
        pathname, filename = self._generate_filename(".tif")
        self._tif_pathname = pathname
        self._tif_filename = filename
        # the download is the tiff file
        self._download_names.append(self._tif_filename)
        self.update()

    def update(self):
        """Update the deep image and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        # save the (deep) image file
        w, h = self._default_size(1920, 1080)
        deep = f",num_samples={self._aa},enhanced=1"
        cmd = f'ensight.render({w},{h}{deep}).save(r"""{self._tif_pathname}""")'
        self._session.cmd(cmd)
        html_source = os.path.join(os.path.dirname(__file__), "deep_pixel_view.html")
        with open(html_source, "r") as fp:
            html = fp.read()
        # copy some files from Nexus
        cmd = "import shutil, enve, ceiversion, os.path\n"
        for script in ["jquery-3.4.1.min.js", "geotiff.js", "geotiff_nexus.js", "bootstrap.min.js"]:
            name = "os.path.join(enve.home(), f'nexus{ceiversion.nexus_suffix}', 'django', "
            name += f"'website', 'static', 'website', 'scripts', '{script}')"
            cmd += f'shutil.copy({name}, r"""{self._session.launcher.session_directory}""")\n'
        name = "os.path.join(enve.home(), f'nexus{ceiversion.nexus_suffix}', 'django', "
        name += "'website', 'static', 'website', 'content', 'bootstrap.min.css')"
        cmd += f'shutil.copy({name}, r"""{self._session.launcher.session_directory}""")\n'
        self._session.cmd(cmd, do_eval=False)
        # replace some bits in the HTML
        tiff_url = f"http://{self._session.hostname}:{self._session.html_port}/{self._tif_filename}"
        html = html.replace("TIFF_URL", tiff_url)
        html = html.replace("ITEMID", self._guid)
        # refresh the remote HTML
        self._save_remote_html_page(html)
        super().update()


class RenderableMP4(Renderable):
    """Animation renderable

    Render the timesteps of the current dataset into an mp4 file and view the results.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "animation"
        self._generate_url()
        # the HTML serves up a PNG file
        pathname, filename = self._generate_filename(".mp4")
        self._mp4_pathname = pathname
        self._mp4_filename = filename
        # the download is the mp4 file
        self._download_names.append(self._mp4_filename)
        self.update()

    def update(self):
        """Update the animation and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        # save the image file on the remote host
        w, h = self._default_size(1920, 1080)

        # get the timestep limits, [0,0] is non-time varying
        st, en = self._session.ensight.objs.core.TIMESTEP_LIMITS
        num_frames = en - st + 1
        self._session.ensight.file.animation_rend_offscreen("ON")
        self._session.ensight.file.animation_stereo("current")
        self._session.ensight.file.animation_screen_tiling(1, 1)
        self._session.ensight.file.animation_format("mpeg4")
        self._session.ensight.file.animation_format_options("Quality High Type 1")
        self._session.ensight.file.animation_frame_rate(self._fps)
        self._session.ensight.file.animation_rend_offscreen("ON")
        self._session.ensight.file.animation_numpasses(self._aa)
        self._session.ensight.file.animation_stereo("current")
        self._session.ensight.file.animation_screen_tiling(1, 1)
        self._session.ensight.file.animation_file(self._mp4_pathname)
        self._session.ensight.file.animation_window_size("user_defined")
        self._session.ensight.file.animation_window_xy(w, h)
        self._session.ensight.file.animation_frames(num_frames)
        self._session.ensight.file.animation_start_number(st)
        self._session.ensight.file.animation_multiple_images("OFF")
        self._session.ensight.file.animation_raytrace_it("OFF")
        self._session.ensight.file.animation_raytrace_ext("OFF")
        self._session.ensight.file.animation_play_flipbook("OFF")
        self._session.ensight.file.animation_play_time("ON")
        self._session.ensight.file.animation_play_keyframe("OFF")
        self._session.ensight.file.animation_reset_flipbook("OFF")
        self._session.ensight.file.animation_reset_traces("OFF")
        self._session.ensight.file.animation_reset_time("ON")
        self._session.ensight.file.animation_reset_keyframe("OFF")
        self._session.ensight.file.save_animation()

        # generate HTML page with file references local to the websocketserver root
        html = f'<video width="{w}" height="{h}" controls>\n'
        html += f'    <source src="/{self._mp4_filename}" type="video/mp4" />\n'
        html += "</video>\n"

        # refresh the remote HTML
        self._save_remote_html_page(html)
        super().update()


class RenderableWebGL(Renderable):
    """WebGL renderable

    Render an AVZ file on the EnSight host system and make it available via
    a webpage.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "webgl"
        self._generate_url()
        pathname, filename = self._generate_filename(".avz")
        self._avz_pathname = pathname
        self._avz_filename = filename
        # the download is the avz file
        self._download_names.append(self._avz_filename)
        self.update()

    def update(self):
        """Update the webgl geometry and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        # save the .avz file
        self._session.ensight.part.select_all()
        self._session.ensight.savegeom.format("avz")
        # current timestep or all of the timesteps
        ts = self._session.ensight.objs.core.TIMESTEP
        st = ts
        en = ts
        if self._temporal:
            st, en = self._session.ensight.objs.core.TIMESTEP_LIMITS
        self._session.ensight.savegeom.begin_step(st)
        self._session.ensight.savegeom.end_step(en)
        self._session.ensight.savegeom.step_by(1)
        # Save the file
        self._session.ensight.savegeom.save_geometric_entities(self._avz_pathname)
        # generate HTML page with file references local to the websocketserver root
        html = "<script src='/ansys/nexus/viewer-loader.js'></script>\n"
        html += f"<ansys-nexus-viewer src='/{self._avz_filename}'></ansys-nexus-viewer>\n"
        # refresh the remote HTML
        self._save_remote_html_page(html)
        super().update()


class RenderableVNC(Renderable):
    """Remote rendering (VNC) renderable

    Generate a URL that can be used to connect to the EnSight VNC remote image renderer.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "remote"
        self.update()

    def update(self):
        """Update the remote rendering widget and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        url = f"http://{self._session.hostname}:{self._session.html_port}"
        url += "/ansys/nexus/novnc/vnc_envision.html"
        url += f"?autoconnect=true&host={self._session.hostname}&port={self._session.ws_port}"
        self._url = url
        super().update()


class RenderableEVSN(Renderable):
    """Remote rendering scene capture (VNC) renderable

    Generate a URL that can be used to connect to the EnVision VNC remote image renderer.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "remote_scene"
        self._generate_url()
        pathname, filename = self._generate_filename(".evsn")
        self._evsn_pathname = pathname
        self._evsn_filename = filename
        pathname, filename = self._generate_filename(".png")
        self._proxy_pathname = pathname
        self._proxy_filename = filename
        # the download is the evsn file
        self._download_names.append(self._evsn_filename)
        self.update()

    def update(self):
        """Update the remote rendering widget and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        # Save the proxy image
        w, h = self._default_size(1920, 1080)
        cmd = f'ensight.render({w},{h},num_samples={self._aa}).save(r"""{self._proxy_pathname}""")'
        self._session.cmd(cmd)
        # save the .evsn file
        self._session.ensight.file.save_scenario_which_parts("all")
        self._session.ensight.file.scenario_format("envision")
        # current timestep or all of the timesteps
        if self._temporal:
            st, en = self._session.ensight.objs.core.TIMESTEP_LIMITS
            self._session.ensight.file.scenario_steptime_anim(1, st, en, 1.0)
        else:
            self._session.ensight.file.scenario_steptime_anim(0, 1, 1, 1)
        varlist = self._session.ensight.objs.core.VARIABLES.find(True, "ACTIVE")
        vars = [x.DESCRIPTION for x in varlist]
        self._session.ensight.variables.select_byname_begin(vars)
        # Save the file
        self._session.ensight.file.save_scenario_fileslct(self._evsn_pathname)

        # generate HTML page with file references local to the websocketserver root
        html = "<script src='/ansys/nexus/viewer-loader.js'></script>\n"
        server = f"http://{self._session.hostname}:{self._session.html_port}"
        cleanname = self._evsn_pathname.replace("\\", "/")
        attributes = f"src='{cleanname}'"
        attributes += f" proxy_img='/{self._proxy_filename}'"
        attributes += " aspect_ratio='proxy'"
        attributes += " renderer='envnc'"
        http_uri = f'"http":"{server}"'
        ws_uri = f'"ws":"http://{self._session.hostname}:{self._session.ws_port}"'
        secrets = f'"security_token":"{self._session.secret_key}"'
        attributes += f"renderer_options='{{ {http_uri}, {ws_uri}, {secrets} }}'"
        html += f"<ansys-nexus-viewer {attributes}></ansys-nexus-viewer>\n"
        # refresh the remote HTML
        self._save_remote_html_page(html)
        super().update()


class RenderableDSG(Renderable):
    """Distributed scene graph renderable

    A webGL-based renderable that leverages the dynamic scene graph interface
    for progressive geometry transport.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._generate_url()
        pathname, filename = self._generate_filename("")
        # on the server, a JSON block can be accessed via:
        # {_dsg_base_pathname}/status.json
        # and the update files:
        # {_dsg_base_pathname}/update_0.dsgz
        self._dsg_base_pathname = pathname
        self._dsg_base_filename = filename
        # Create the directory where the status file and .dsgz files will go
        cmd = f'import os\nos.mkdir(r"""{self._dsg_base_pathname}""")\n'
        self._session.cmd(cmd, do_eval=False)
        # keep track of the number of updates...
        self._last_update_number = -1
        # and the last complete update
        self._last_full_update = -1
        # get a stream ID
        self._stream_id = self._session.ensight.dsg_new_stream()
        self.update()

    def update(self, incremental: bool = True):
        """Generate a DSG update

        Cause the EnSight session to generate a DSG update and cause any attached
        webGL viewer to (eventually) display the results.

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        Args:
            incremental:
                If True, the update will incremental instead of full
        """
        # save an update, initial update will not be incremental
        if self._last_full_update < 0:
            incremental = False

        # next update
        self._last_update_number += 1
        if not incremental:
            self._last_full_update = self._last_update_number

        # Ask for an update to be generated
        remote_filename = f"{self._dsg_base_pathname}/update_{self._last_update_number}.dsgz"
        self._session.ensight.dsg_save_update(
            remote_filename,
            temporal=self._temporal,
            incremental=incremental,
            stream=self._stream_id,
        )

        # Update the proxy image
        self._update_proxy()

        # Record the file(s) to the status file...
        status = dict(
            magic="dsg_status_file_v1.0",
            latest_update=self._last_update_number,
            latest_fullupdate=self._last_full_update,
        )
        # Save json over to file in EnSight session
        content = json.dumps(status)
        remote_filename = f"{self._dsg_base_pathname}/status.json"
        cmd = f'open(r"""{remote_filename}""", "w").write("""{content}""")'
        self._session.cmd(cmd, do_eval=False)

        # If the first update, generate the HTML
        if self._last_update_number == 0:
            # generate HTML page with file references local to the websocketserver root
            attributes = f"src='/{self._dsg_base_filename}/update_0.dsgz'"
            attributes += f" proxy_img='/{self._dsg_base_filename}/proxy.png'"
            attributes += " aspect_ratio='proxy'"
            html = "<script src='/ansys/nexus/viewer-loader.js'></script>\n"
            html += f"<ansys-nexus-viewer {attributes}></ansys-nexus-viewer>\n"
            # refresh the remote HTML
            self._save_remote_html_page(html)
        super().update()

    def _update_proxy(self):
        """Replace the current proxy image with the current view"""
        # save a proxy image
        w, h = self._default_size(1920, 1080)
        remote_filename = f"{self._dsg_base_pathname}/proxy.png"
        cmd = f'ensight.render({w},{h},num_samples={self._aa}).save(r"""{remote_filename}""")'
        self._session.cmd(cmd, do_eval=False)

    def delete(self) -> None:
        try:
            _ = self._session.ensight.dsg_close_stream(self._stream_id)
        except Exception:
            pass
        super().delete()
