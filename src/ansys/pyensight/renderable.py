"""Renderable module

Interface to create objects in the EnSight session that can be displayed
via HTML over the websocketserver interface.
"""
import os
from typing import Any, Optional
import uuid
import webbrowser


class Renderable:
    """Generate HTML pages for renderable entities

    This class provides the underlying HTML remote webpage generation for
    the Session 'show()' method.  The approach is to generate the renderable
    in the EnSight session and make the artifacts available via the websocketserver.
    The artifacts are then wrapped with simple HTML pages (also served up by
    websocket server) which can be used to populate iframes, etc.

    Args:
        session:
            The pyansys session to generate the renderables for
    """

    def __init__(
        self,
        session: "pyansys.Session",
        cell_handle: Optional[Any] = None,
        width: Optional[int] = None,
        height: Optional[int] = None,
        temporal: bool = False,
        aa: int = 1,
    ) -> None:
        self._session = session
        self._filename_index: int = 0
        self._guid: str = str(uuid.uuid1()).replace("-", "")
        # The Jupyter notebook cell handle (if any)
        self._cell_handle = cell_handle
        # the URL to the base HTML file for this entity
        self._url: Optional[str] = None
        # the pathname of the HTML file in the remote EnSight session
        self._url_remote_pathname: Optional[str] = None
        # the name passed to the pyensight session show() string
        self._rendertype: str = ""
        # Common attributes used by various subclasses
        self._width: Optional[int] = width
        self._height: Optional[int] = height
        self._temporal: bool = temporal
        self._aa: int = aa

    def __repr__(self) -> str:
        name = self.__class__.__name__
        return f"{name}( url='{self._url}' )"

    def _repr_pretty_(self, p: "pretty", cycle: bool) -> None:
        """Support the pretty module for better IPython support"""
        name = self.__class__.__name__
        p.text(f"{name}( url='{self._url}' )")

    def _generate_filename(self, suffix: str) -> (str, str):
        """Create new session specific files and urls

        Every time this method is called, a new filename (on the EnSight host)
        and the associated URL for that file are generated.  The caller
        provides the suffix for the names.

        Args:
             suffix:
                The suffix to be appended to the names.  For example: ".png"
        Returns:
            the filename to use on the host system and the URL that accesses the
            file via REST calls to websocketserver
        """
        filename = f"{self._session.secret_key}_{self._guid}_{self._filename_index}{suffix}"
        # Note: cannot use os.path.join here as the OS of the EnSight session might not match
        # the client OS.
        pathname = f"{self._session.launcher.session_directory}/{filename}"
        self._filename_index += 1
        return pathname, filename

    def _generate_url(self) -> None:
        # On the remote system the pathname to the HTML file will be:
        #   {session_directory}/{session}_{guid}_{index}_{type}.html
        # The URL to the file (through the session HTTP server):
        #   http://{system}:{websocketserverhtmlport}/{session}_{guid}_{index}_{type}.html
        suffix = f"_{self._rendertype}.html"
        filename_index = self._filename_index
        remote_pathname, _ = self._generate_filename(suffix)
        simple_filename = f"{self._session.secret_key}_{self._guid}_{filename_index}{suffix}"
        url = f"http://{self._session.hostname}:{self._session.html_port}/{simple_filename}"
        self._url = url
        self._url_remote_pathname = remote_pathname

    def _save_remote_html_page(self, html: str) -> None:
        """Create an HTML webpage on the remote host

        Given a snippet of HTML, create a new file on the remote server with the
        name generated by _generate_url().
        The most common use is to generate an "iframe" wrapper around some html.

        Args:
            html:
                The HTML snippet to be wrapped remotely
        """
        # save "html" into a file on the remote server with filename .html
        cmd = f'open(r"""{self._url_remote_pathname}""", "w").write("""{html}""")'
        self._session.grpc.command(cmd, do_eval=False)

    def browser(self) -> None:
        """Open a webbrowser page to display the renderable content"""
        if self._url:
            webbrowser.open(self._url)

    @property
    def url(self) -> str:
        """The URL to the renderable content"""
        return self._url

    def _default_size(self, width: int, height: int) -> (int, int):
        """Propose and return a size for a rectangle

        The renderable may have been constructed with user-supplied width and height
        information.  If so, that information is returned.  If not, the width and
        height values passed to this method are returned.

        Args:
            width:
                The width value to be returned if the renderable does not have a width
            height:
                The height value to be returned if the renderable does not have a height

        Returns:
            A tuple (width, height) of the size values to be used.
        """
        out_w = self._width
        if out_w is None:
            out_w = width
        out_h = self._height
        if out_h is None:
            out_h = height
        return out_w, out_h

    def update(self) -> None:
        """Update the visualization and display it

        When this method is called, the graphics content will be updated to the
        current EnSight instance state (e.g. an image might be re-captured).  The
        URL of the content stays the same, but the content that URL displays is
        updated.

        If the renderable was created in the context of a Jupyter notebook cell,
        the original cell display is updated.
        """
        if self._cell_handle:
            from IPython.display import IFrame

            width, height = self._default_size(800, 600)
            self._cell_handle.update(IFrame(src=self._url, width=width, height=height))

    def delete(self) -> None:
        """Delete all the server resources for this renderable

        A renderable occupies resources in the EnSight session instance.  This
        method will release those resources.  Once it is called, the renderable can
        no longer be displayed.

        Note: this method has not yet been implemented.
        """
        pass


class RenderableImage(Renderable):
    """Image renderable

    Render an image on the EnSight host system and make it available via
    a webpage.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "image"
        self._generate_url()
        # the HTML serves up a PNG file
        pathname, filename = self._generate_filename(".png")
        self._png_pathname = pathname
        self._png_filename = filename
        self.update()

    def update(self):
        """Update the image and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        # save the image file on the remote host
        w, h = self._default_size(1920, 1080)
        cmd = f'ensight.render({w},{h},num_samples={self._aa}).save(r"""{self._png_pathname}""")'
        self._session.cmd(cmd)
        # generate HTML page with file references local to the websocketserver root
        html = f'<img src="/{self._png_filename}">\n'
        # refresh the remote HTML
        self._save_remote_html_page(html)
        super().update()


class RenderableDeepPixel(Renderable):
    """Deep Image renderable

    Render a deep pixel image on the EnSight host system and make it available via
    a webpage.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "deep_pixel"
        self._generate_url()
        pathname, filename = self._generate_filename(".tif")
        self._tif_pathname = pathname
        self._tif_filename = filename
        self.update()

    def update(self):
        """Update the deep image and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        # save the (deep) image file
        w, h = self._default_size(1920, 1080)
        deep = f",num_samples={self._aa},enhanced=1"
        cmd = f'ensight.render({w},{h}{deep}).save(r"""{self._tif_pathname}""")'
        self._session.cmd(cmd)
        html_source = os.path.join(os.path.dirname(__file__), "deep_pixel_view.html")
        with open(html_source, "r") as fp:
            html = fp.read()
        # copy some files from Nexus
        cmd = "import shutil, enve, ceiversion, os.path\n"
        for script in ["jquery-3.4.1.min.js", "geotiff.js", "geotiff_nexus.js", "bootstrap.min.js"]:
            name = "os.path.join(enve.home(), f'nexus{ceiversion.nexus_suffix}', 'django', "
            name += f"'website', 'static', 'website', 'scripts', '{script}')"
            cmd += f'shutil.copy({name}, r"""{self._session.launcher.session_directory}""")\n'
        name = "os.path.join(enve.home(), f'nexus{ceiversion.nexus_suffix}', 'django', "
        name += "'website', 'static', 'website', 'content', 'bootstrap.min.css')"
        cmd += f'shutil.copy({name}, r"""{self._session.launcher.session_directory}""")\n'
        self._session.cmd(cmd, do_eval=False)
        # replace some bits in the HTML
        tiff_url = f"http://{self._session.hostname}:{self._session.html_port}/{self._tif_filename}"
        html = html.replace("TIFF_URL", tiff_url)
        html = html.replace("ITEMID", self._guid)
        # refresh the remote HTML
        self._save_remote_html_page(html)
        super().update()


class RenderableWebGL(Renderable):
    """WebGL renderable

    Render an AVZ file on the EnSight host system and make it available via
    a webpage.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "webgl"
        self._generate_url()
        pathname, filename = self._generate_filename(".avz")
        self._avz_pathname = pathname
        self._avz_filename = filename
        self.update()

    def update(self):
        """Update the webgl geometry and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        # save the .avz file
        self._session.grpc.command("ensight.part.select_all()", do_eval=False)
        self._session.grpc.command('ensight.savegeom.format("avz")', do_eval=False)
        # current timestep or all of the timesteps
        ts = self._session.ensight.objs.core.TIMESTEP
        st = ts
        en = ts
        if self._temporal:
            st, en = self._session.ensight.objs.core.TIMESTEP_LIMITS
        self._session.grpc.command(f"ensight.savegeom.begin_step({st})", do_eval=False)
        self._session.grpc.command(f"ensight.savegeom.end_step({en})", do_eval=False)
        self._session.grpc.command("ensight.savegeom.step_by(1)", do_eval=False)
        # Save the file
        cmd = f'ensight.savegeom.save_geometric_entities(r"""{self._avz_pathname}""")'
        self._session.grpc.command(cmd, do_eval=False)
        # generate HTML page with file references local to the websocketserver root
        html = "<script src='/ansys/nexus/viewer-loader.js'></script>\n"
        html += f"<ansys-nexus-viewer src='/{self._avz_filename}'></ansys-nexus-viewer>\n"
        # refresh the remote HTML
        self._save_remote_html_page(html)
        super().update()


class RenderableVNC(Renderable):
    """Remote rendering (VNC) renderable

    Generate a URL that can be used to connect to the EnSight VNC remote image renderer.
    """

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._rendertype = "remote"
        self.update()

    def update(self):
        """Update the remote rendering widget and display it

        If the renderable is part of a Jupyter cell, that cell is updated as an IFrame reference.

        """
        url = f"http://{self._session.hostname}:{self._session.html_port}"
        url += "/ansys/nexus/novnc/vnc_envision.html"
        url += f"?autoconnect=true&host={self._session.hostname}&port={self._session.ws_port}"
        self._url = url
        super().update()
