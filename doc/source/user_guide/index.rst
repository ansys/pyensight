  
.. |CAMERA|  replace:: :class:`ENS_CAMERA<pyensight.ens_camera.ENS_CAMERA>`
.. |CASE|  replace:: :class:`ENS_CASE<pyensight.ens_case.ENS_CASE>`
.. |GLOBALS|  replace:: :class:`ENS_GLOBALS<pyensight.ens_globals.ENS_GLOBALS>`
.. |LIGHTSOURCE|  replace:: :class:`ENS_LIGHTSOURCE<pyensight.ens_lightsource.ENS_LIGHTSOURCE>`
.. |PROBE|  replace:: :class:`ENS_PROBE<pyensight.ens_probe.ENS_PROBE>`
.. |TEXTURE|  replace:: :class:`ENS_TEXTURE<pyensight.ens_texture.ENS_TEXTURE>`
.. |TOOL|  replace:: :class:`ENS_TOOL<pyensight.ens_tool.ENS_TOOL>`
.. |TOOL_BOX|  replace:: :class:`ENS_TOOL_BOX<pyensight.ens_tool_box.ENS_TOOL_BOX>`
.. |TOOL_CONE|  replace:: :class:`ENS_TOOL_CONE<pyensight.ens_tool_cone.ENS_TOOL_CONE>`
.. |TOOL_SPHERE|  replace:: :class:`ENS_TOOL_SPHERE<pyensight.ens_tool_sphere.ENS_TOOL_SPHERE>`
.. |TOOL_CURSOR|  replace:: :class:`ENS_TOOL_CURSOR<pyensight.ens_tool_cursor.ENS_TOOL_CURSOR>`
.. |TOOL_CYLINDER|  replace:: :class:`ENS_TOOL_CYLINDER<pyensight.ens_tool_cylinder.ENS_TOOL_CYLINDER>`
.. |TOOL_LINE|  replace:: :class:`ENS_TOOL_LINE<pyensight.ens_tool_line.ENS_TOOL_LINE>`
.. |TOOL_PLANE|  replace:: :class:`ENS_TOOL_PLANE<pyensight.ens_tool_plane.ENS_TOOL_PLANE>`
.. |TOOL_REVOLUTION|  replace:: :class:`ENS_TOOL_REVOLUTION<pyensight.ens_tool_revolution.ENS_TOOL_REVOLUTION>`
.. |VPORT|  replace:: :class:`ENS_VPORT<pyensight.ens_vport.ENS_VPORT>`				 

.. |ANNOT|  replace:: :class:`ENS_ANNOT<pyensight.ens_annot.ENS_ANNOT>`
.. |ANNOT_ARROW|  replace:: :class:`ENS_ANNOT_ARROW<pyensight.ens_annot_arrow.ENS_ANNOT_ARROW>`
.. |ANNOT_DIAL|  replace:: :class:`ENS_ANNOT_DIAL<pyensight.ens_annot_dial.ENS_ANNOT_DIAL>`
.. |ANNOT_GAUGE|  replace:: :class:`ENS_ANNOT_GAUGE<pyensight.ens_annot_gauge.ENS_ANNOT_GAUGE>`
.. |ANNOT_LGND|  replace:: :class:`ENS_ANNOT_LGND<pyensight.ens_annot_lgnd.ENS_ANNOT_LGND>`
.. |ANNOT_LINE|  replace:: :class:`ENS_ANNOT_LINE<pyensight.ens_annot_line.ENS_ANNOT_LINE>`
.. |ANNOT_LOGO|  replace:: :class:`ENS_ANNOT_LOGO<pyensight.ens_annot_logo.ENS_ANNOT_LOGO>`
.. |ANNOT_SHAPE|  replace:: :class:`ENS_ANNOT_SHAPE<pyensight.ens_annot_shape.ENS_ANNOT_SHAPE>`
.. |ANNOT_TEXT|  replace:: :class:`ENS_ANNOT_TEXT<pyensight.ens_annot_text.ENS_ANNOT_TEXT>`
.. |GROUP|  replace:: :class:`ENS_GROUP<pyensight.ens_group.ENS_GROUP>`
.. |LPART|  replace:: :class:`ENS_LPART<pyensight.ens_lpart.ENS_LPART>`
.. |PALETTE|  replace:: :class:`ENS_PALETTE<pyensight.ens_palette.ENS_PALETTE>`
.. |PART|  replace:: :class:`ENS_PART<pyensight.ens_part.ENS_PART>`
.. |PART_AUX_GEOM|  replace:: :class:`ENS_PART_AUX_GEOM<pyensight.ens_part_aux_geom.ENS_PART_AUX_GEOM>`
.. |PART_BUILT_UP|  replace:: :class:`ENS_PART_BUILT_UP<pyensight.ens_part_built_up.ENS_PART_BUILT_UP>`
.. |PART_CLIP|  replace:: :class:`ENS_PART_CLIP<pyensight.ens_part_clip.ENS_PART_CLIP>`
.. |PART_CONTOUR|  replace:: :class:`ENS_PART_CONTOUR<pyensight.ens_part_contour.ENS_PART_CONTOUR>`
.. |PART_DEVELOPED_SURFACE|  replace:: :class:`ENS_PART_DEVELOPED_SURFACE<pyensight.ens_part_developed_surface.ENS_PART_DEVELOPED_SURFACE>`
.. |PART_ELEVATED_SURFACE|  replace:: :class:`ENS_PART_ELEVATED_SURFACE<pyensight.ens_part_elevated_surface.ENS_PART_ELEVATED_SURFACE>`
.. |PART_FILTER|  replace:: :class:`ENS_PART_FILTER<pyensight.ens_part_filter.ENS_PART_FILTER>`
.. |PART_FX_SEP_ATT|  replace:: :class:`ENS_PART_FX_SEP_ATT<pyensight.ens_part_fx_sep_att.ENS_PART_FX_SEP_ATT>`
.. |PART_FX_SHOCK|  replace:: :class:`ENS_PART_FX_SHOCK<pyensight.ens_part_fx_shock.ENS_PART_FX_SHOCK>`
.. |PART_FX_VORTEX_CORE|  replace:: :class:`ENS_PART_FX_VORTEX_CORE<pyensight.ens_part_fx_vortex_core.ENS_PART_FX_VORTEX_CORE>`
.. |PART_ISOSURFACE|  replace:: :class:`ENS_PART_ISOSURFACE<pyensight.ens_part_isosurface.ENS_PART_ISOSURFACE>`
.. |PART_MODEL|  replace:: :class:`ENS_PART_MODEL<pyensight.ens_part_model.ENS_PART_MODEL>`
.. |PART_PARTICLE_TRACE|  replace:: :class:`ENS_PART_PARTICLE_TRACE<pyensight.ens_part_particle_trace.ENS_PART_PARTICLE_TRACE>`
.. |PART_POINT|  replace:: :class:`ENS_PART_POINT<pyensight.ens_part_point.ENS_PART_POINT>`
.. |PART_PROFILE|  replace:: :class:`ENS_PART_PROFILE<pyensight.ens_part_profile.ENS_PART_PROFILE>`
.. |PART_TENSOR_GLYPH|  replace:: :class:`ENS_PART_TENSOR_GLYPH<pyensight.ens_part_tensor_glyph.ENS_PART_TENSOR_GLYPH>`
.. |PART_VECTOR_ARROW|  replace:: :class:`ENS_PART_VECTOR_ARROW<pyensight.ens_part_vector_arrow.ENS_PART_VECTOR_ARROW>`
.. |PLOTTER|  replace:: :class:`ENS_PLOTTER<pyensight.ens_plotter.ENS_PLOTTER>`
.. |POLYLINE|  replace:: :class:`ENS_POLYLINE<pyensight.ens_polyline.ENS_POLYLINE>`
.. |QUERY|  replace:: :class:`ENS_QUERY<pyensight.ens_query.ENS_QUERY>`
.. |VAR|  replace:: :class:`ENS_VAR<pyensight.ens_var.ENS_VAR>`


.. _user_guide:

User guide
==========

In these pages we will describe the relationship between the various EnSight Python
interfaces and the EnSight core.

.. toctree::
   :maxdepth: 1
   :hidden:

   cmdlang_native
   object_api
   api_differences


EnSight and PyEnSight Interfaces
--------------------------------

There is a Python interpreter embedded in the EnSight desktop application.  In
general that interpreter is referred to as the 'EnSight' or 'embedded' interpreter.
This interface is based on a built-in 'ensight' module that cannot be imported
into any other interpreter.  It is the fastest Python interface to EnSight and
much of EnSight itself is written in Python running in this interpreter.

The other interface is PyEnSight.  This interface is implemented as a portable
wheel and can be installed in most any Python interpreter.  The interface provided
by this component resides in the ansys.pyensight module.  It is a 'remote' interface
in that it actually starts an independent EnSight instance in another process and
connects to it.  Over that connection, the pyensight interface makes it possible
to execute Python commands in the embedded interpreter and return results.
The pyensight interface has a nearly identical API to the embedded interface
so code written for one interface will basically work in the other if the code
is structured properly.  See: :ref:`api_differences` for more differences.


History: Native and Object APIs
-------------------------------

The EnSight application has always has a journaling language, often referred to
as 'command language' or 'cmdlang'.  This system made it possible to view and
review every interaction in EnSight as a command stream and users could play
back the journal streams to automate tasks.

Around EnSight 9.x, an embedded Python interpreter was introduced into the EnSight
core.  The initial language binding to EnSight was via the 'native API'.  The native
API is derived from the EnSight journaling language.  It is basically a direct Python
mapping with object specific conversion operations to simplify the interface.  See
:ref:`ref_cmdlang_native` for more details.  This interface is the most complete
interface to EnSight and there are tools in the EnSight script editor that allow
for the conversion of blocks of command language into this Python API.

As the sophistication of Python scripts increased, users began to run into limitations
in the journal-based interface.  In response, the object API was developed.
The object API is a direct interface to the core C++ EnSight objects.  It is a
proxy interface that exposes C++ object attribute interfaces as Python
properties.  The advantages of the object API is support for fine grained
queries and event handling. See :ref:`ref_object_api` for more details.  This
API does not as of yet cover all of the ground the native API does, but it
allows for more interactive and reactive components interfaces to be used.
So much so, that a significant portion of the EnSight GUI is written using
this API.


EnSight Architecture
--------------------

The EnSight Python APIs reflect the core EnSight architecture.  Specifically,
they reflect the various objects inside of EnSight and their relationships.
The interface to these objects is largely a collection of properties. Note,
these are properties in the PyEnSight interface.  The core interface refers to
them as attributes and properties almost interchangeably in documentation.

There are two types of objects in EnSight.  The first set are part of the code and are
generally created automatically at startup.
Note: in the following sections, many of the core classes are described in brief.  This
is not a complete list, only commonly used objects.

There are two unique concepts in the EnSight architecture that are important in
helping explain core EnSight behavior.  The first is the idea of hierarchical property filtering
and the second being the concept of default objects.

Hierarchical Property Filters
`````````````````````````````

A number of properties have "global" versions as well as per-object versions.
Often a specific visual property must be enabled globally and then the
object specific value is applied.  This can happen at different levels in
the visible object tree.  Consider the hidden line property: HIDDENLINE.  This property can
be set on ENS_PART, ENS_VPORT and ENS_GLOBAL levels.  In the object API::

    print(ensight.objs.core.HIDDENLINE)
    print(ensight.objs.core.VPORTS[0].HIDDENLINE)
    print(ensight.objs.core.PARTS[0].HIDDENLINE)

If the property is False at the ENS_PART level, hidden lines will never be displayed on that part.
If the property is False at the ENS_VPORT level, no hidden lines will be displayed on
any parts that might be viable (and have HIDDENLINE True) in the specific ENS_VPORT.
If the property is False at the ENS_GLOBAL level (ensight.objs.core) then no hidden lines
will be displayed on any parts in any viewports.


Default Objects
```````````````

The default object is a key concept for EnSight.  To create a new object in EnSight,
one will often set up the properties on a fake, "default" object and then make a "create"
call to realize a new object of that type.  The new object will have the same properties
as the current default object properties.  Specific examples
are covered in the :ref:`ref_object_api` and :ref:`ref_cmdlang_native`
sections.


Common Static Objects
`````````````````````

There are fixed number of each of these objects and they are all allocated
statically at startup.  The Python API allows for attributes on these objects
to be modified and their status queried.  The key object is ENS_GLOBAL which
is accessed via ensight.objs.core.  Properties on the ENS_GLOBAL object can generally
access all of the other objects in the system.
The various properties on these objects are documented here: :ref:`ref_api_docs`.

================ ==================================================
Class            Description
================ ==================================================
|CAMERA|         Cameras are used to set up views of the current scene.
                 They can be associated with viewports and attached to
                 polylines, nodes and other graphics entities.
|CASE|           Case objects are used to read a dataset.  There are a
                 fixed number of case objects that can be active and
                 each case can load a dataset in a different format.
|GLOBALS|        The globals object provides an interface to the
                 core EnSight state.  All of the objects
                 cane be accessed via properties on this object.
|LIGHTSOURCE|    The EnSight scene supports a finite number of
                 preallocated lighting sources.  These objects
                 provide the interface to the light properties.
|PROBE|          The probe object allows for creation of spatial data
                 probes.  The result of probe queries can be
                 accessed via this object.
|TEXTURE|        Texture object maintain the pixel arrays that can
                 be applied via projective or explicit texture coordinates.
|TOOL|           Tools are spatial input devices in the scene.  They
                 allow for the selection of points, regions of space,
                 reference lines/planes, etc.  There are several
                 unique tools types.  The PyEnSight API uses these
                 subclasses for each tool singleton.

                 =================== ===========================================
                 Subclass            Description
                 =================== ===========================================
                 |TOOL_BOX|          box.
                 |TOOL_CONE|         line segment with a base radius.
                 |TOOL_SPHERE|       sphere.
                 |TOOL_CURSOR|       single point.
                 |TOOL_CYLINDER|     line segment with fixed radius.
                 |TOOL_LINE|         line segment.
                 |TOOL_PLANE|        bounded plane.
                 |TOOL_REVOLUTION|   line segment with a list of radii.
                 =================== ===========================================

|VPORT|          There are a fixed number of independent viewports.
                 Each viewport has an independent camera/projection
                 and the visibility of all 3D objects can be specified
                 independently for each viewport.
================ ==================================================


Common Dynamic Objects
``````````````````````

There are fixed number of each of these objects and they are all allocated
statically at startup.  The Python API allows for attributes on these objects
to be modified and their status queried.

Many of the dynamically created objects are created implicitly through other
objects.  For example, part objects are created from lpart objects and legend
objects are created automatically when variable objects are created.  Other
objects (e.g., annotation objects and derived part objects like clips) are
created using "default" objects.
The various properties on these objects are documented here: :ref:`ref_api_docs`.

================ ==================================================
Class            Description
================ ==================================================
|ANNOT|          Annotation base class.  Annotations are mostly 2D objects that
                 overlay the 3D scene.  Things like text blocks, lines, etc.
                 There are more complex types, for example a legend annotation
                 is used to display the palette associated with a variable.
                 The PyEnSight API uses specific subclasses for each annotation
                 type.

                 =============== ===============================================
                 Subclass        Description
                 =============== ===============================================
                 |ANNOT_ARROW|   3D arrow pointing at a location in data space.
                 |ANNOT_DIAL|    display of a constant variable as a dial.
                 |ANNOT_GAUGE|   display of a constant variable as a linear gauge.
                 |ANNOT_LGND|    legend representation of a variable palette.
                                 Note: these are only created by ENS_VAR objects.
                 |ANNOT_LINE|    single line.
                 |ANNOT_LOGO|    image annotation.
                 |ANNOT_SHAPE|   generic 2D shapes: box, circle and 2D arrow.
                 |ANNOT_TEXT|    block of 2D overlay text.
                 =============== ===============================================

|GROUP|          Group objects play two roles.  First, they provide a
                 hierarchical interface to collections of ENS_PART, ENS_LPART
                 objects for display in the GUI or general organization.  Second,
                 groups can be the output of a find operation, which can be handy
                 since they support fast, recursive, bulk property changes.
|LPART|          The LPART object represents an unloaded mesh object in a dataset.
                 LPART objects are created by ENS_CASE objects when a case loads a dataset.
                 The LPART object is used to create ENS_PART objects from a dataset.
                 In most cases, these objects are automatically leveraged when a
                 dataset is loaded.
|PALETTE|        These objects are allocated dynamically, but only indirectly under user
                 control. Every ENS_VARIABLE object has one or more ENS_PALETTE objects.
                 One for scalars and four for vectors ([X],[Y],[Z],mag).
|PART|           A PART object represents a block of geometry in the current scene.  The
                 geometry can come from the dataset on disk (via an LPART) or it can come
                 from part "creation" methods for example: iso-contour, clips, profiles,
                 vortex cores, etc.
                 The PyEnSight API uses specific subclasses for each annotation
                 type.  They all represent a mesh consisting of a collection of elements.
                 Usually these are located in the EnSight server, but in some cases they
                 are realized in the client.

                 ========================== ======================================================
                 Subclass                   Description
                 ========================== ======================================================
                 |PART_AUX_GEOM|            An auxiliary geometry part allows for scripted creation
                                            of objects like boxes that can be used in other
                                            calculations or to enhance visualizations (e.g., for a
                                            backdrop).
                 |PART_BUILT_UP|            This part is more commonly known as a "subset" part. It
                                            allows for collections of elements/nodes to be selected
                                            from a set of input parts.  These are merged into this
                                            part.
                 |PART_CLIP|                Created by clipping a parent set of parts.
                 |PART_CONTOUR|             The result of contouring a parent set of parts.
                 |PART_DEVELOPED_SURFACE|   A developed surface is generated by treating any
                                            2D Part (or parent Part) as a surface of revolution,
                                            and mapping specific curvilinear coordinates of the
                                            revolved surface into a planar representation.
                 |PART_ELEVATED_SURFACE|    For a given collection of 2D parent parts, this
                                            part presents a displacement of the surface of the
                                            parents based on a specific variable and various
                                            parameters.
                 |PART_FILTER|              A filter part is created by applying a collection of
                                            variable range filters to a collection of parent parts.
                 |PART_FX_SEP_ATT|          Separation and attachment lines can be created on
                                            2D surfaces.  These help visualize areas where flow
                                            abruptly leaves or returns to the 2D surface in 3D flow
                                            fields.
                 |PART_FX_SHOCK|            Shock region parts help visualize shock waves in a 3D
                                            flow field. Shock waves are characterized by an abrupt
                                            increase in density, energy, and pressure gradients,
                                            as well as a simultaneous sudden decrease in the
                                            velocity gradient.
                 |PART_FX_VORTEX_CORE|      Vortex cores help visualize the centers of swirling
                                            flow in a flow field. EnSight creates vortex core
                                            segments from the velocity gradient tensor of 3D flow
                                            field part(s).
                 |PART_ISOSURFACE|          Created by applying isosurfacing to a parent set of
                                            parts.
                 |PART_MODEL|               Read from a dataset via an LPART.
                 |PART_PARTICLE_TRACE|      Particle traces generated by integrating points
                                            through a vector field defined on a collection of
                                            parent parts.
                 |PART_POINT|               This part can be created via API or from a file.  It is
                                            a list of points.  Commonly, the point tool is used to
                                            generate these parts.
                 |PART_PROFILE|             Profile parts are created by combining a 1D entity
                                            (line clip, contour, particle trace) with a surface
                                            part.  The profile of a specific variable, sampled over
                                            the 1D entity is captured in a profile part.
                 |PART_TENSOR_GLYPH|        A part representing a tensor field on a collection of
                                            parts as a collection of orientated and colored glyphs.
                 |PART_VECTOR_ARROW|        A part representing a vector field on a collection of
                                            parts as a collection of orientated and colored arrows.
                 ========================== ======================================================

|PLOTTER|        A plotter object is a visual frame for displaying one or more ENS_QUERY objects.
                 It includes axis, title, backgrounds, borders, legends, etc.
|POLYLINE|       Polyline objects are called splines in EnSight.  They can be used to set up
                 things like camera paths.
|QUERY|          Query objects represent y = f(x) data.  This data can come directly from a dataset,
                 created when the ENS_CASE object loads a dataset, or queries can be created using
                 loaded/computed data.  For example, one could query the values of pressure along
                 a line segment through a PART of volumetric elements.
|VAR|            Variable objects represent a specific field variable, case or part constant.
                 The base object contains the metadata associated with the variable (e.g.,
                 ranges, etc).  Variables can be introduced directly from datasets, but they
                 can also be created using calculator functions.
================ ==================================================
