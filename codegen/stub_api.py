"""Generate .py files from current EnSight API .xml description

Usage
-----

`python generate_stub_api.py`
"""
import datetime
import glob
import os.path
import sys
from xml.etree import ElementTree

import requests


class ProcessAPI:
    """Convert an XML API representation into classes

    Args:
        data:
            XML string
    """

    def __init__(self, data: str) -> None:
        self._root: ElementTree.Element = ElementTree.fromstring(data)

    @staticmethod
    def cap1(s: str):
        return s[0].upper() + s[1:]

    @staticmethod
    def process_variable(node: ElementTree.Element, indent: str = ""):
        """Process <variable> tag

        Variable tags are converted into class members
        """
        var_type = node.get("type", "Any")
        s = f"{indent}self.{node.get('name')}: {var_type}"
        if node.text:
            if var_type == "str":
                s += f" = '{node.text}'"
            else:
                s += f" = {node.text}"
        return s + "\n"

    @staticmethod
    def process_argument(node: ElementTree.Element):
        """Process <argument> tag

        Argument tags are placed inside of member function bindings
        """
        arg_type = node.get("type", "Any")
        if arg_type == "var":
            arg_type = "Any"
        s = f"{node.get('name')}: {arg_type}"
        if node.text:
            if arg_type == "str":
                s += f" = '{node.text}'"
            else:
                s += f" = {node.text}"
        return s

    def process_method(self, node: ElementTree.Element, indent: str = ""):
        """Process <method> tag

        Map a method tag to a 'def' member function
        """
        s = "\n"
        s += f"{indent}def {node.get('name')}(self"
        ret = ""
        arg_names = []
        for child in node:
            if child.tag == "return":
                ret = child.get("type")
            elif child.tag == "argument":
                arg = self.process_argument(child)
                arg_names.append(f"{{repr({child.get('name')})}}")
                s += ", "
                s += f"{arg}"
        if ret:
            s += f") -> {ret}:\n"
        else:
            s += f"):\n"
        indent += "    "
        desc = node.get("description", "")
        if desc:
            desc = self.cap1(desc)
            s += f'{indent}"""{desc}\n'
            s += f'{indent}"""\n'
        s += f"{indent}cmd = f'''"
        s += node.get("ns") + "("
        s += ",".join(arg_names)
        s += ")'''\n"
        s += f"{indent}return self._session.cmd(cmd)\n"
        return s

    def process_module(self, node: ElementTree.Element, indent: str = ""):
        """Process a <module> tag

        Module tags are converted into classes
        """
        s = "\n\n"
        s += f"{indent}class {node.get('name')}:\n"
        indent += "    "
        desc = node.get("description", f"class wrapper for EnSight {node.get('name')} module")
        desc = self.cap1(desc)
        s += f'{indent}"""{desc}\n'
        s += f"{indent}This class acts as a proxy for an EnSight Python module\n"
        s += "__ATTRIBUTES__"
        s += f'{indent}"""\n'
        s += f"{indent}def __init__(self, session: Session):\n"
        s += f"{indent}    self._session = session\n"
        attributes = ""
        # walk the children
        methods = ""
        for child in node:
            if child.tag == "variable":
                s += self.process_variable(child, indent=f"{indent}    ")
                attributes += f"{indent}    {child.get('name')}:\n"
                attributes += f"{indent}        Instance specific constant\n"
            elif child.tag == "module":
                # Prepend the submodule
                name = child.get("name")
                s = self.process_module(child) + s
                # add an instance of the class to the current class
                s += f"{indent}    self.{name}: '{name}' = {name}(self._session)\n"
                attributes += f"{indent}    {name}:\n"
                attributes += f"{indent}        EnSight module instance clas\n"
            elif child.tag == "method":
                methods += self.process_method(child, indent=indent)
        s += methods
        if attributes:
            attributes = f"\n{indent}Attributes:\n" + attributes + "\n"
        return s.replace("__ATTRIBUTES__", attributes)

    def process(self, filename: str) -> None:
        (name, _) = os.path.splitext(os.path.basename(filename))
        s = f'"""Module {name}\n'
        s += f"Autogenerated from: {name}.xml at {datetime.datetime.now().isoformat()}\n"
        s += '"""\n'
        s += "from ansys.pyensight import Session\n"
        s += "from typing import Any\n"
        for child in self._root:
            if child.tag == "module":
                s += self.process_module(child)
                s += "\n\n"
        with open(filename, "w") as f:
            f.write(s)


def generate_stub_api() -> None:
    """Build the EnSight API bindings

    Pull the .xml file from the archive and run the tool on it.
    """
    root = os.path.dirname(__file__)
    os.chdir(root)

    # Get the default Ansys version number
    sys.path.append("../src")
    from ansys import pyensight  # pylint: disable=import-outside-toplevel

    version = pyensight.__ansys_version__

    # cleanup old files
    for filename in glob.glob("*.xml"):
        os.unlink(filename)
    target_dir = "../src/ansys/pyensight"

    # get the API file(s)
    api_uris = [f"https://s3.amazonaws.com/www3.ensight.com/build/v{version}/ensight_api.xml"]
    for uri in api_uris:
        result = requests.get(uri)
        if not result.ok:
            raise RuntimeError(f"URL fetch error: {result.status_code} ({uri})")
        api_name = os.path.basename(uri)
        with open(api_name, "w", encoding="utf8") as fp:
            fp.write(result.text)
        generator = ProcessAPI(result.text)
        outname = os.path.join(target_dir, api_name.replace(".xml", ".py"))
        generator.process(outname)


def generate() -> None:
    generate_stub_api()


if __name__ == "__main__":
    generate()
